// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wlroots/wlroots/-/raw/0.16.2/protocol/wlr-layer-shell-unstable-v1.xml
//
// wlr_layer_shell_unstable_v1 Protocol Copyright:
//
// Copyright Â© 2017 Drew DeVault
//
// Permission to use, copy, modify, distribute, and sell this
// software and its documentation for any purpose is hereby granted
// without fee, provided that the above copyright notice appear in
// all copies and that both that copyright notice and this permission
// notice appear in supporting documentation, and that the name of
// the copyright holders not be used in advertising or publicity
// pertaining to distribution of the software without specific,
// written prior permission.  The copyright holders make no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied
// warranty.
//
// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.

package wlr_layer_shell

import (
	"github.com/rajveermalviya/go-wayland/wayland/client"
	xdg_shell "github.com/rajveermalviya/go-wayland/wayland/stable/xdg-shell"
)

// LayerShell : create surfaces that are layers of the desktop
//
// Clients can use this interface to assign the surface_layer role to
// wl_surfaces. Such surfaces are assigned to a "layer" of the output and
// rendered with a defined z-depth respective to each other. They may also be
// anchored to the edges and corners of a screen and specify input handling
// semantics. This interface should be suitable for the implementation of
// many desktop shell components, and a broad number of other applications
// that interact with the desktop.
type LayerShell struct {
	client.BaseProxy
}

// NewLayerShell : create surfaces that are layers of the desktop
//
// Clients can use this interface to assign the surface_layer role to
// wl_surfaces. Such surfaces are assigned to a "layer" of the output and
// rendered with a defined z-depth respective to each other. They may also be
// anchored to the edges and corners of a screen and specify input handling
// semantics. This interface should be suitable for the implementation of
// many desktop shell components, and a broad number of other applications
// that interact with the desktop.
func NewLayerShell(ctx *client.Context) *LayerShell {
	zwlrLayerShellV1 := &LayerShell{}
	ctx.Register(zwlrLayerShellV1)
	return zwlrLayerShellV1
}

// GetLayerSurface : create a layer_surface from a surface
//
// Create a layer surface for an existing surface. This assigns the role of
// layer_surface, or raises a protocol error if another role is already
// assigned.
//
// Creating a layer surface from a wl_surface which has a buffer attached
// or committed is a client error, and any attempts by a client to attach
// or manipulate a buffer prior to the first layer_surface.configure call
// must also be treated as errors.
//
// After creating a layer_surface object and setting it up, the client
// must perform an initial commit without any buffer attached.
// The compositor will reply with a layer_surface.configure event.
// The client must acknowledge it and is then allowed to attach a buffer
// to map the surface.
//
// You may pass NULL for output to allow the compositor to decide which
// output to use. Generally this will be the one that the user most
// recently interacted with.
//
// Clients can specify a namespace that defines the purpose of the layer
// surface.
//
//	layer: layer to add this surface to
//	namespace: namespace for the layer surface
func (i *LayerShell) GetLayerSurface(surface *client.Surface, output *client.Output, layer uint32, namespace string) (*LayerSurface, error) {
	id := NewLayerSurface(i.Context())
	const opcode = 0
	namespaceLen := client.PaddedLen(len(namespace) + 1)
	_reqBufLen := 8 + 4 + 4 + 4 + 4 + (4 + namespaceLen)
	_reqBuf := make([]byte, _reqBufLen)
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], surface.ID())
	l += 4
	if output == nil {
		client.PutUint32(_reqBuf[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(_reqBuf[l:l+4], output.ID())
		l += 4
	}
	client.PutUint32(_reqBuf[l:l+4], uint32(layer))
	l += 4
	client.PutString(_reqBuf[l:l+(4+namespaceLen)], namespace, namespaceLen)
	l += (4 + namespaceLen)
	err := i.Context().WriteMsg(_reqBuf, nil)
	return id, err
}

// Destroy : destroy the layer_shell object
//
// This request indicates that the client will not use the layer_shell
// object any more. Objects that have been created through this instance
// are not affected.
func (i *LayerShell) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type LayerShellError uint32

// LayerShellError :
const (
	// LayerShellErrorRole : wl_surface has another role
	LayerShellErrorRole LayerShellError = 0
	// LayerShellErrorInvalidLayer : layer value is invalid
	LayerShellErrorInvalidLayer LayerShellError = 1
	// LayerShellErrorAlreadyConstructed : wl_surface has a buffer attached or committed
	LayerShellErrorAlreadyConstructed LayerShellError = 2
)

func (e LayerShellError) Name() string {
	switch e {
	case LayerShellErrorRole:
		return "role"
	case LayerShellErrorInvalidLayer:
		return "invalid_layer"
	case LayerShellErrorAlreadyConstructed:
		return "already_constructed"
	default:
		return ""
	}
}

func (e LayerShellError) Value() string {
	switch e {
	case LayerShellErrorRole:
		return "0"
	case LayerShellErrorInvalidLayer:
		return "1"
	case LayerShellErrorAlreadyConstructed:
		return "2"
	default:
		return ""
	}
}

func (e LayerShellError) String() string {
	return e.Name() + "=" + e.Value()
}

type LayerShellLayer uint32

// LayerShellLayer : available layers for surfaces
//
// These values indicate which layers a surface can be rendered in. They
// are ordered by z depth, bottom-most first. Traditional shell surfaces
// will typically be rendered between the bottom and top layers.
// Fullscreen shell surfaces are typically rendered at the top layer.
// Multiple surfaces can share a single layer, and ordering within a
// single layer is undefined.
const (
	LayerShellLayerBackground LayerShellLayer = 0
	LayerShellLayerBottom     LayerShellLayer = 1
	LayerShellLayerTop        LayerShellLayer = 2
	LayerShellLayerOverlay    LayerShellLayer = 3
)

func (e LayerShellLayer) Name() string {
	switch e {
	case LayerShellLayerBackground:
		return "background"
	case LayerShellLayerBottom:
		return "bottom"
	case LayerShellLayerTop:
		return "top"
	case LayerShellLayerOverlay:
		return "overlay"
	default:
		return ""
	}
}

func (e LayerShellLayer) Value() string {
	switch e {
	case LayerShellLayerBackground:
		return "0"
	case LayerShellLayerBottom:
		return "1"
	case LayerShellLayerTop:
		return "2"
	case LayerShellLayerOverlay:
		return "3"
	default:
		return ""
	}
}

func (e LayerShellLayer) String() string {
	return e.Name() + "=" + e.Value()
}

// LayerSurface : layer metadata interface
//
// An interface that may be implemented by a wl_surface, for surfaces that
// are designed to be rendered as a layer of a stacked desktop-like
// environment.
//
// Layer surface state (layer, size, anchor, exclusive zone,
// margin, interactivity) is double-buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// Attaching a null buffer to a layer surface unmaps it.
//
// Unmapping a layer_surface means that the surface cannot be shown by the
// compositor until it is explicitly mapped again. The layer_surface
// returns to the state it had right after layer_shell.get_layer_surface.
// The client can re-map the surface by performing a commit without any
// buffer attached, waiting for a configure event and handling it as usual.
type LayerSurface struct {
	client.BaseProxy
	configureHandler LayerSurfaceConfigureHandlerFunc
	closedHandler    LayerSurfaceClosedHandlerFunc
}

// NewLayerSurface : layer metadata interface
//
// An interface that may be implemented by a wl_surface, for surfaces that
// are designed to be rendered as a layer of a stacked desktop-like
// environment.
//
// Layer surface state (layer, size, anchor, exclusive zone,
// margin, interactivity) is double-buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// Attaching a null buffer to a layer surface unmaps it.
//
// Unmapping a layer_surface means that the surface cannot be shown by the
// compositor until it is explicitly mapped again. The layer_surface
// returns to the state it had right after layer_shell.get_layer_surface.
// The client can re-map the surface by performing a commit without any
// buffer attached, waiting for a configure event and handling it as usual.
func NewLayerSurface(ctx *client.Context) *LayerSurface {
	zwlrLayerSurfaceV1 := &LayerSurface{}
	ctx.Register(zwlrLayerSurfaceV1)
	return zwlrLayerSurfaceV1
}

// SetSize : sets the size of the surface
//
// Sets the size of the surface in surface-local coordinates. The
// compositor will display the surface centered with respect to its
// anchors.
//
// If you pass 0 for either value, the compositor will assign it and
// inform you of the assignment in the configure event. You must set your
// anchor to opposite edges in the dimensions you omit; not doing so is a
// protocol error. Both values are 0 by default.
//
// Size is double-buffered, see wl_surface.commit.
func (i *LayerSurface) SetSize(width, height uint32) error {
	const opcode = 0
	const _reqBufLen = 8 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(width))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetAnchor : configures the anchor point of the surface
//
// Requests that the compositor anchor the surface to the specified edges
// and corners. If two orthogonal edges are specified (e.g. 'top' and
// 'left'), then the anchor point will be the intersection of the edges
// (e.g. the top left corner of the output); otherwise the anchor point
// will be centered on that edge, or in the center if none is specified.
//
// Anchor is double-buffered, see wl_surface.commit.
func (i *LayerSurface) SetAnchor(anchor uint32) error {
	const opcode = 1
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(anchor))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetExclusiveZone : configures the exclusive geometry of this surface
//
// Requests that the compositor avoids occluding an area with other
// surfaces. The compositor's use of this information is
// implementation-dependent - do not assume that this region will not
// actually be occluded.
//
// A positive value is only meaningful if the surface is anchored to one
// edge or an edge and both perpendicular edges. If the surface is not
// anchored, anchored to only two perpendicular edges (a corner), anchored
// to only two parallel edges or anchored to all edges, a positive value
// will be treated the same as zero.
//
// A positive zone is the distance from the edge in surface-local
// coordinates to consider exclusive.
//
// Surfaces that do not wish to have an exclusive zone may instead specify
// how they should interact with surfaces that do. If set to zero, the
// surface indicates that it would like to be moved to avoid occluding
// surfaces with a positive exclusive zone. If set to -1, the surface
// indicates that it would not like to be moved to accommodate for other
// surfaces, and the compositor should extend it all the way to the edges
// it is anchored to.
//
// For example, a panel might set its exclusive zone to 10, so that
// maximized shell surfaces are not shown on top of it. A notification
// might set its exclusive zone to 0, so that it is moved to avoid
// occluding the panel, but shell surfaces are shown underneath it. A
// wallpaper or lock screen might set their exclusive zone to -1, so that
// they stretch below or over the panel.
//
// The default value is 0.
//
// Exclusive zone is double-buffered, see wl_surface.commit.
func (i *LayerSurface) SetExclusiveZone(zone int32) error {
	const opcode = 2
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(zone))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetMargin : sets a margin from the anchor point
//
// Requests that the surface be placed some distance away from the anchor
// point on the output, in surface-local coordinates. Setting this value
// for edges you are not anchored to has no effect.
//
// The exclusive zone includes the margin.
//
// Margin is double-buffered, see wl_surface.commit.
func (i *LayerSurface) SetMargin(top, right, bottom, left int32) error {
	const opcode = 3
	const _reqBufLen = 8 + 4 + 4 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(top))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(right))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(bottom))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(left))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetKeyboardInteractivity : requests keyboard events
//
// Set how keyboard events are delivered to this surface. By default,
// layer shell surfaces do not receive keyboard events; this request can
// be used to change this.
//
// This setting is inherited by child surfaces set by the get_popup
// request.
//
// Layer surfaces receive pointer, touch, and tablet events normally. If
// you do not want to receive them, set the input region on your surface
// to an empty region.
//
// Keyboard interactivity is double-buffered, see wl_surface.commit.
func (i *LayerSurface) SetKeyboardInteractivity(keyboardInteractivity uint32) error {
	const opcode = 4
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(keyboardInteractivity))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// GetPopup : assign this layer_surface as an xdg_popup parent
//
// This assigns an xdg_popup's parent to this layer_surface.  This popup
// should have been created via xdg_surface::get_popup with the parent set
// to NULL, and this request must be invoked before committing the popup's
// initial state.
//
// See the documentation of xdg_popup for more details about what an
// xdg_popup is and how it is used.
func (i *LayerSurface) GetPopup(popup *xdg_shell.Popup) error {
	const opcode = 5
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], popup.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// AckConfigure : ack a configure event
//
// When a configure event is received, if a client commits the
// surface in response to the configure event, then the client
// must make an ack_configure request sometime before the commit
// request, passing along the serial of the configure event.
//
// If the client receives multiple configure events before it
// can respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending
// an ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing, but
// only the last request sent before a commit indicates which configure
// event the client really is responding to.
//
//	serial: the serial from the configure event
func (i *LayerSurface) AckConfigure(serial uint32) error {
	const opcode = 6
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Destroy : destroy the layer_surface
//
// This request destroys the layer surface.
func (i *LayerSurface) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 7
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetLayer : change the layer of the surface
//
// Change the layer that the surface is rendered on.
//
// Layer is double-buffered, see wl_surface.commit.
//
//	layer: layer to move this surface to
func (i *LayerSurface) SetLayer(layer uint32) error {
	const opcode = 8
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(layer))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type LayerSurfaceKeyboardInteractivity uint32

// LayerSurfaceKeyboardInteractivity : types of keyboard interaction possible for a layer shell surface
//
// Types of keyboard interaction possible for layer shell surfaces. The
// rationale for this is twofold: (1) some applications are not interested
// in keyboard events and not allowing them to be focused can improve the
// desktop experience; (2) some applications will want to take exclusive
// keyboard focus.
const (
	LayerSurfaceKeyboardInteractivityNone      LayerSurfaceKeyboardInteractivity = 0
	LayerSurfaceKeyboardInteractivityExclusive LayerSurfaceKeyboardInteractivity = 1
	LayerSurfaceKeyboardInteractivityOnDemand  LayerSurfaceKeyboardInteractivity = 2
)

func (e LayerSurfaceKeyboardInteractivity) Name() string {
	switch e {
	case LayerSurfaceKeyboardInteractivityNone:
		return "none"
	case LayerSurfaceKeyboardInteractivityExclusive:
		return "exclusive"
	case LayerSurfaceKeyboardInteractivityOnDemand:
		return "on_demand"
	default:
		return ""
	}
}

func (e LayerSurfaceKeyboardInteractivity) Value() string {
	switch e {
	case LayerSurfaceKeyboardInteractivityNone:
		return "0"
	case LayerSurfaceKeyboardInteractivityExclusive:
		return "1"
	case LayerSurfaceKeyboardInteractivityOnDemand:
		return "2"
	default:
		return ""
	}
}

func (e LayerSurfaceKeyboardInteractivity) String() string {
	return e.Name() + "=" + e.Value()
}

type LayerSurfaceError uint32

// LayerSurfaceError :
const (
	// LayerSurfaceErrorInvalidSurfaceState : provided surface state is invalid
	LayerSurfaceErrorInvalidSurfaceState LayerSurfaceError = 0
	// LayerSurfaceErrorInvalidSize : size is invalid
	LayerSurfaceErrorInvalidSize LayerSurfaceError = 1
	// LayerSurfaceErrorInvalidAnchor : anchor bitfield is invalid
	LayerSurfaceErrorInvalidAnchor LayerSurfaceError = 2
	// LayerSurfaceErrorInvalidKeyboardInteractivity : keyboard interactivity is invalid
	LayerSurfaceErrorInvalidKeyboardInteractivity LayerSurfaceError = 3
)

func (e LayerSurfaceError) Name() string {
	switch e {
	case LayerSurfaceErrorInvalidSurfaceState:
		return "invalid_surface_state"
	case LayerSurfaceErrorInvalidSize:
		return "invalid_size"
	case LayerSurfaceErrorInvalidAnchor:
		return "invalid_anchor"
	case LayerSurfaceErrorInvalidKeyboardInteractivity:
		return "invalid_keyboard_interactivity"
	default:
		return ""
	}
}

func (e LayerSurfaceError) Value() string {
	switch e {
	case LayerSurfaceErrorInvalidSurfaceState:
		return "0"
	case LayerSurfaceErrorInvalidSize:
		return "1"
	case LayerSurfaceErrorInvalidAnchor:
		return "2"
	case LayerSurfaceErrorInvalidKeyboardInteractivity:
		return "3"
	default:
		return ""
	}
}

func (e LayerSurfaceError) String() string {
	return e.Name() + "=" + e.Value()
}

type LayerSurfaceAnchor uint32

// LayerSurfaceAnchor :
const (
	// LayerSurfaceAnchorTop : the top edge of the anchor rectangle
	LayerSurfaceAnchorTop LayerSurfaceAnchor = 1
	// LayerSurfaceAnchorBottom : the bottom edge of the anchor rectangle
	LayerSurfaceAnchorBottom LayerSurfaceAnchor = 2
	// LayerSurfaceAnchorLeft : the left edge of the anchor rectangle
	LayerSurfaceAnchorLeft LayerSurfaceAnchor = 4
	// LayerSurfaceAnchorRight : the right edge of the anchor rectangle
	LayerSurfaceAnchorRight LayerSurfaceAnchor = 8
)

func (e LayerSurfaceAnchor) Name() string {
	switch e {
	case LayerSurfaceAnchorTop:
		return "top"
	case LayerSurfaceAnchorBottom:
		return "bottom"
	case LayerSurfaceAnchorLeft:
		return "left"
	case LayerSurfaceAnchorRight:
		return "right"
	default:
		return ""
	}
}

func (e LayerSurfaceAnchor) Value() string {
	switch e {
	case LayerSurfaceAnchorTop:
		return "1"
	case LayerSurfaceAnchorBottom:
		return "2"
	case LayerSurfaceAnchorLeft:
		return "4"
	case LayerSurfaceAnchorRight:
		return "8"
	default:
		return ""
	}
}

func (e LayerSurfaceAnchor) String() string {
	return e.Name() + "=" + e.Value()
}

// LayerSurfaceConfigureEvent : suggest a surface change
//
// The configure event asks the client to resize its surface.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// The client is free to dismiss all but the last configure event it
// received.
//
// The width and height arguments specify the size of the window in
// surface-local coordinates.
//
// The size is a hint, in the sense that the client is free to ignore it if
// it doesn't resize, pick a smaller size (to satisfy aspect ratio or
// resize in steps of NxM pixels). If the client picks a smaller size and
// is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the
// surface will be centered on this axis.
//
// If the width or height arguments are zero, it means the client should
// decide its own window dimension.
type LayerSurfaceConfigureEvent struct {
	Serial uint32
	Width  uint32
	Height uint32
}
type LayerSurfaceConfigureHandlerFunc func(LayerSurfaceConfigureEvent)

// SetConfigureHandler : sets handler for LayerSurfaceConfigureEvent
func (i *LayerSurface) SetConfigureHandler(f LayerSurfaceConfigureHandlerFunc) {
	i.configureHandler = f
}

// LayerSurfaceClosedEvent : surface should be closed
//
// The closed event is sent by the compositor when the surface will no
// longer be shown. The output may have been destroyed or the user may
// have asked for it to be removed. Further changes to the surface will be
// ignored. The client should destroy the resource after receiving this
// event, and create a new surface if they so choose.
type LayerSurfaceClosedEvent struct{}
type LayerSurfaceClosedHandlerFunc func(LayerSurfaceClosedEvent)

// SetClosedHandler : sets handler for LayerSurfaceClosedEvent
func (i *LayerSurface) SetClosedHandler(f LayerSurfaceClosedHandlerFunc) {
	i.closedHandler = f
}

func (i *LayerSurface) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.configureHandler == nil {
			return
		}
		var e LayerSurfaceConfigureEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Width = client.Uint32(data[l : l+4])
		l += 4
		e.Height = client.Uint32(data[l : l+4])
		l += 4

		i.configureHandler(e)
	case 1:
		if i.closedHandler == nil {
			return
		}
		var e LayerSurfaceClosedEvent

		i.closedHandler(e)
	}
}
